def recAOStar(n):
    global optimal_child_group
    and_nodes = allNodes.get(n, {}).get('AND', [])
    or_nodes = allNodes.get(n, {}).get('OR', [])

    if not and_nodes and not or_nodes:
        return

    solvable = False
    marked = set()

    while not solvable:
        if len(marked) == len(and_nodes) + len(or_nodes):
            min_cost_least, min_cost_group_least = least_cost_group(and_nodes, or_nodes, {})
            solvable = True
            change_heuristic(n, min_cost_least)
            optimal_child_group[n] = min_cost_group_least
            continue

        min_cost, min_cost_group = least_cost_group(and_nodes, or_nodes, marked)
        is_expanded = expand_if_needed(min_cost_group)
        
        if is_expanded or min_cost_group == least_cost_group(and_nodes, or_nodes, {})[1]:
            solvable = True
            change_heuristic(n, min_cost if not is_expanded else min_cost_group[0])
            optimal_child_group[n] = min_cost_group
        else:
            solvable = True
            change_heuristic(n, min_cost)
            optimal_child_group[n] = min_cost_group

        marked.add(min_cost_group)

    return heuristic(n)

def least_cost_group(and_nodes, or_nodes, marked):
    node_wise_cost = {}

    for node_pair in and_nodes:
        key = node_pair[0] + node_pair[1]
        if key not in marked:
            cost = sum(heuristic(node) for node in node_pair) + 2
            node_wise_cost[key] = cost

    for node in or_nodes:
        if node not in marked:
            cost = heuristic(node) + 1
            node_wise_cost[node] = cost

    min_cost_group = min(node_wise_cost, key=node_wise_cost.get, default=None)
    min_cost = node_wise_cost.get(min_cost_group, 0)

    return min_cost, min_cost_group

def expand_if_needed(min_cost_group):
    is_expanded = False
    if isinstance(min_cost_group, tuple):
        for node in min_cost_group:
            if node in allNodes:
                recAOStar(node)
                is_expanded = True
    elif min_cost_group in allNodes:
        recAOStar(min_cost_group)
        is_expanded = True

    return is_expanded

def heuristic(n):
    return H_dist.get(n, 0)

def change_heuristic(n, cost):
    H_dist[n] = cost

def print_path(node):
    print(optimal_child_group[node], end="")
    node = optimal_child_group[node]

    if len(node) > 1:
        for child in node:
            if child in optimal_child_group:
                print("->", end="")
                print_path(child)
    else:
        if node in optimal_child_group:
            print("->", end="")
            print_path(node)

H_dist = {'A': -1, 'B': 4, 'C': 2, 'D': 3, 'E': 6, 'F': 8, 'G': 2, 'H': 0, 'I': 0, 'J': 0}
allNodes = {'A': {'AND': [('C', 'D')], 'OR': ['B']}, 'B': {'OR': ['E', 'F']}, 'C': {'OR': ['G'], 'AND': [('H', 'I')]}, 'D': {'OR': ['J']}}
optimal_child_group = {}

optimal_cost = recAOStar('A')
print('Nodes which give optimal cost are')
print_path('A')
print('\nOptimal Cost is ::', optimal_cost)
